# 常见的数据结构

- [数组](##Array)
- [数组链表](##Chain)
- [哈希表](##Hash Map)

## Array

计算机中的数组与数学中的数组概念类似，只是计算机中的数组的值可以是多种类型。
一般语言中的数组，指的都是连续线性表，也就是所有元素依次存储在一片连续的存储空间内，但js比较特殊，js中的数据结构就只有一种：哈希表。
哈希表用来描述Object，其他所有的数据结构，都是建立在哈希表上的伪结构。比如数组，其实就是key为index的对象，其底层，也就是哈希表。

> ES6中的typed Array和ArrayBuffer是存储连续内存的数组，与传统意义上的数组一样。

对于传统的数组来说，由于数据保存在连续的内存块中、数组头保存了数组的地址，所以数据的定位是非常方便的。
根据数组地址+元素的偏移量算出指定元素的内存地址，直接移动指针到该处即可进行数据的读写。

但是由于数据存储的空间连续，所以对元素的增删就变得非常麻烦，比如要在第五位插入一个元素，那么第五位后面的所有元素都要向后挪一个数组空间的位置。
实际操作中我们还需要额外的临时空间来保存要移动的元素，然后依次移动各个元素，相当繁琐。

![数组插入动画](resource/Array001.png)

PS：js中常规的数组操作这里不做介绍，仅介绍数据结构原理。

## Chain

因为数组增删非常麻烦，所以链表这种数据结构就被设计出来了。
链表元素的存储空间都是分散的，每个元素除了保存本身的值之外，还保存着其他元素的内存地址，根据地址就可以将整个链表串起来了。
根据这个特点，只要我们改写一个元素指向的内存地址指向一个新的链表元素，然后设置新的链表元素指向原来元素指向的地址，就插入了一个链表元素。
由于链表的所有元素的实际内存地址并不连续，所以也就不必像定义数组一样声明其存储空间了，换言之链表占用的是动态空间。

![数组插入动画](resource/Chain001.jpg)

js中没有指针和内存地址的概念，这些底层实现都是由js引擎实现的，所以在js中不会使用链表，而是直接使用更为强大的对象

## Hash Map

js中Object的底层实现就是哈希表结构，哈希表是一种比较高级的数据结构。

在真实世界中，我们的数据有很多是线性表类型，但更多的是以属性-值这样的键值对出现的数据，比如个人信息中的name:Jack,age:18。
这种键值对结构几乎遍布面向对象编程的各个角落，当我们有这样的很多这样的键值对时，我们怎么才能方便地访问到特定的key呢？
无论是使用数组还是链表，都无法直接存储key-value这样的键值对。
当然，你可以将key-value整体存在数组或者链表的value里面去，那如果要访问到特定的key，只能遍历了。

我们知道，数组的定位是非常简单的，只要指定下标就可以直接移动指针到相应的位置进行数据读写，
那很自然就会想到，有没有办法将key转换成一个数组下标，将所有数据放入数组中，然后通过这个下标来直接访问相应的value呢？
也就是 key >> index >> value, 只要知道index=f(key)这个映射关系，我们就可以将数据存到数组里面然后直接通过array[f(key)]来访问了。
看起来很简单了，前提是我们定义的 f 函数能够将我们的key都分散到不同的下标里面，而f函数这就是所谓的散列函数了。

举个栗子：对于一组key（15,22,33,40,50），如果我们想找到40，那么就要一个一个做对比，遍历到40的时候才知道40的位置在第4位。
假如我设定一个散列算法为index=key/10，那么我们只需要一次计算就能得到index=40/10=4。
实际应用中，我们的key都是长度不定的字符串或者数字，将这些字符串通过一定的规则转换成数字，然后散列到一定范围内，就可以使用数组的定位属性来帮助定位数据了。

如果数组空间内保存的是链表的头地址，这样的结构就变得非常灵活了，而整个数据结构，就变成了一个二维表，这就是哈希表。

上面将数组和链表组合成哈希表的方法，叫拉链法。

这样，我们就可以直接用{key:value,key2:value2}的方式来表示一个对象数据了。

但是，由于key是未知的，可以说是无限的，但我们又要将无限的key塞进有限的空间内，那么就会出现两个不同的key得到同样的index的结果。
这种现象无法避免，也就是说无论使用哪种散列算法，都有可能出现冲突。出现冲突意味着我们要去区分这两个冲突，否则数据就会丢失，所以我们总是希望发生冲突的概率尽可能的小。
但是由于散列算法是应用在每一次数据定位中的，它的使用频率非常的高，这意味着我们必须要选择简单的算法。

而发生冲突之后，我们必须要有相应的策略去解决冲突。由于拉链法中数组空间内保存的是一个链表，所以，我们可以将冲突的值依次放入链表内，

散列算法有很多，这里简单介绍几种。
1，除法散列法
最直观的一种，上图使用的就是这种散列法，公式：
index = key % 16
学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。
显然，当key为18和34的时候，输出的index是一样的，这个时候我们可以将18和34都放入数组下标为2的链表中。链表元素除了保存value之外，也把这个key（18，34）保存下来。在遍历链表的时候对比key就可以知道具体是哪一个key了。


2，平方散列法
求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：
index = (value * value) >> 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）
如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。

3，斐波那契（Fibonacci）散列法

平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。

1，对于16位整数而言，这个乘数是40503
2，对于32位整数而言，这个乘数是2654435769
3，对于64位整数而言，这个乘数是11400714819323198485

这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,233, 377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。另外，斐波那契数列的值和太阳系八大行星的轨道半径的比例出奇吻合。

对我们常见的32位整数而言，公式：
index = (value * 2654435769) >> 28






