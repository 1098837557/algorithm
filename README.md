# 一些常见的算法实现

- [数组相关](#Array)
- [哈希表](#Hash Map)

## Array

#### indexOfArray：数组子串位置查询

#### arrayFilter：数组筛选

#### arrayUnique: 数组去重

#### combineArray: 数组归并排序

#### longestSubArray: 数组最长无重复子串查找

#### longestSubArrayHash: 利用哈希表去重的数组最长无重复子串查找

## Hash Map

先简单介绍下哈希表。
在真实世界中，我们的数据有很多是数组，但更多的是以属性-值这样的键值对出现的数据，比如个人信息中的name:Jack,age:18。
当我们有这样的很多这样的键值对时，我们怎么才能方便地访问到特定的key呢？
无论是使用数组还是链表，都无法直接存储key-value这样的键值对。
当然，你可以将key-value整体存在数组或者链表的value里面去，那如果要访问到特定的key，只能遍历了。

我们知道，数组的定位是非常简单的，只要指定下标就可以直接移动指针到相应的位置进行数据读写，
那很自然就会想到，有没有办法将key转换成一个数组下标，将所有数据放入数组中，然后通过这个下标来直接访问相应的value呢？
也就是 key >> index >> value, 只要知道index=f(key)这个映射关系，我们就可以将数据存到数组里面然后直接通过array[f(key)]来访问了。
看起来很简单了，前提是我们定义的 f 函数能够将我们的key都分散到不同的下标里面，而f函数这就是所谓的散列函数了。
数组空间里面如果只放一个值，未免也太浪费，如果我们将一个链表的头放到数组空间里面去，这样就能得到一个二维表了，这，就是哈希表。

上面的方法，就叫拉链法。

但是，由于key是未知的，可以说是无限的，所以任一输入一个key都能输出一个独一无二的index这显然是不可能的，



